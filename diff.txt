diff --git a/cpp/CMakeLists.txt b/cpp/CMakeLists.txt
index 5fe0a92..ce552d7 100644
--- a/cpp/CMakeLists.txt
+++ b/cpp/CMakeLists.txt
@@ -2,6 +2,8 @@ cmake_minimum_required(VERSION 2.8 FATAL_ERROR)
 
 project(ahc)
 
+add_definitions(-DUSE_BOOST_SHARED_PTR)
+
 find_package(OpenCV REQUIRED)
 find_package(PCL 1.2 REQUIRED)
 
@@ -17,4 +19,4 @@ install(TARGETS plane_fitter DESTINATION bin)
 add_executable(plane_fitter_pcd plane_fitter_pcd.cpp)
 target_link_libraries(plane_fitter_pcd ${PCL_LIBRARIES} ${OpenCV_LIBS})
 install(TARGETS plane_fitter_pcd DESTINATION bin)
-install(FILES plane_fitter_pcd.ini DESTINATION bin)
\ No newline at end of file
+install(FILES plane_fitter_pcd.ini DESTINATION bin)
diff --git a/cpp/plane_fitter.cpp b/cpp/plane_fitter.cpp
index c100e54..dfbdefd 100644
--- a/cpp/plane_fitter.cpp
+++ b/cpp/plane_fitter.cpp
@@ -29,7 +29,8 @@
 #define _CRT_SECURE_NO_WARNINGS
 
 #include <pcl/point_types.h>
-#include <pcl/io/openni_grabber.h>
+#include <pcl/io/openni2_grabber.h>
+#include <pcl/visualization/cloud_viewer.h>
 
 #include "opencv2/opencv.hpp"
 
@@ -40,7 +41,7 @@ using ahc::utils::Timer;
 // pcl::PointCloud interface for our ahc::PlaneFitter
 template<class PointT>
 struct OrganizedImage3D {
-	const pcl::PointCloud<PointT>& cloud;
+        const pcl::PointCloud<PointT> &cloud;
 	//NOTE: pcl::PointCloud from OpenNI uses meter as unit,
 	//while ahc::PlaneFitter assumes mm as unit!!!
 	const double unitScaleFactor;
@@ -68,15 +69,15 @@ public:
 	MainLoop () : done(false) {}
 
 	//process a new frame of point cloud
-	void onNewCloud (const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr &cloud)
+        void onNewCloud (const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr &cloud)
 	{
 		//fill RGB
-		if(rgb.empty() || rgb.rows!=cloud->height || rgb.cols!=cloud->width) {
-			rgb.create(cloud->height, cloud->width, CV_8UC3);
+	        if(rgb.empty() || rgb.rows!=cloud->height || rgb.cols!=cloud->width) {
+		        rgb.create(cloud->height, cloud->width, CV_8UC3);
 			seg.create(cloud->height, cloud->width, CV_8UC3);
 		}
 		for(int i=0; i<(int)cloud->height; ++i) {
-			for(int j=0; j<(int)cloud->width; ++j) {
+		        for(int j=0; j<(int)cloud->width; ++j) {
 				const pcl::PointXYZRGBA& p=cloud->at(j,i);
 				if(!pcl_isnan(p.z)) {
 					rgb.at<cv::Vec3b>(i,j)=cv::Vec3b(p.b,p.g,p.r);
@@ -107,10 +108,9 @@ public:
 	}
 
 	//start the main loop
-	void run ()
+	void run (char* device_name)
 	{
-		pcl::Grabber* grabber = new pcl::OpenNIGrabber();
-
+	        pcl::Grabber* grabber = new pcl::io::OpenNI2Grabber(device_name);
 		boost::function<void (const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr&)> f =
 			boost::bind (&MainLoop::onNewCloud, this, _1);
 
@@ -156,9 +156,21 @@ public:
 	}
 };
 
-int main ()
+int main (int argc, char** argv)
 {
+        char device_name[32] = "";
+
+        if(argc >= 2)
+	{
+	  std::memcpy(device_name, argv[1], std::strlen(argv[1]));
+	}
+	else
+	{
+	  // skip
+	}
+	std::cout << "device_name : " << device_name << std::endl;
+	
 	MainLoop loop;
-	loop.run();
+	loop.run(device_name);
 	return 0;
-}
\ No newline at end of file
+}
diff --git a/cpp/plane_fitter_pcd.cpp b/cpp/plane_fitter_pcd.cpp
index b07b41c..2bd5543 100644
--- a/cpp/plane_fitter_pcd.cpp
+++ b/cpp/plane_fitter_pcd.cpp
@@ -138,7 +138,7 @@ std::string getNameNoExtension(const std::string &fileName)
 }
 
 void iniLoad(std::string iniFileName) {
-	std::ifstream in(iniFileName);
+        std::ifstream in(iniFileName.c_str());
 	if(!in.is_open()) {
 		std::cout<<"[iniLoad] "<<iniFileName<<" not found, use default parameters!"<<std::endl;
 		return;
@@ -307,4 +307,4 @@ int process() {
 int main(const int argc, const char** argv) {
 	global::iniLoad("plane_fitter_pcd.ini");
 	return process();
-}
\ No newline at end of file
+}
diff --git a/include/AHCPlaneFitter.hpp b/include/AHCPlaneFitter.hpp
index 6c57d24..848f972 100644
--- a/include/AHCPlaneFitter.hpp
+++ b/include/AHCPlaneFitter.hpp
@@ -132,7 +132,7 @@ namespace ahc {
 		//std::vector<std::vector<int>> blkMembership; //blkMembership[i] contains all block id for extractedPlanes[i]
 		bool dirtyBlkMbship;
 		std::vector<cv::Vec3b> colors;
-		std::vector<std::pair<int,int>> rfQueue;//for region grow/floodfill, p.first=pixidx, p.second=plid
+		std::vector<std::pair<int,int> > rfQueue;//for region grow/floodfill, p.first=pixidx, p.second=plid
 		bool drawCoarseBorder;
 		//std::vector<PlaneSeg::Stats> blkStats;
 #if defined(DEBUG_INIT) || defined(DEBUG_CLUSTER)
@@ -201,7 +201,7 @@ namespace ahc {
 		 *  \details this function corresponds to Algorithm 1 in our paper
 		 */
 		double run(const Image3D* pointsIn,
-			std::vector<std::vector<int>>* pMembership=0,
+			std::vector<std::vector<int> >* pMembership=0,
 			cv::Mat* pSeg=0,
 			const std::vector<int> * const pIdxMap=0, bool verbose=true)
 		{
@@ -254,6 +254,7 @@ namespace ahc {
 		/**
 		 *  \brief print out the current parameters
 		 */
+#if 0  // ToDo: This solution is not elegant. should be modified!
 		void logParams() const {
 #define TMP_LOG_VAR(var) << #var "="<<(var)<<"\n"
 			std::cout<<"[PlaneFitter] Parameters:\n"
@@ -277,6 +278,7 @@ namespace ahc {
 			TMP_LOG_VAR(doRefine)<<std::endl;
 #undef TMP_LOG_VAR
 		}
+#endif
 
 		/************************************************************************/
 		/* Protected Class Functions                                            */
@@ -287,7 +289,7 @@ namespace ahc {
 		 *  
 		 *  \details this function corresponds to Algorithm 4 in our paper; note: plane parameters of each extractedPlanes in the PlaneSeg is NOT updated after this call since the new points added from region grow and points removed from block erosion are not properly reflected in the PlaneSeg
 		 */
-		void refineDetails(std::vector<std::vector<int>> *pMembership, //pMembership->size()==nPlanes
+		void refineDetails(std::vector<std::vector<int> > *pMembership, //pMembership->size()==nPlanes
 			const std::vector<int> * const pIdxMap, //if pIdxMap!=0 pMembership->at(i).at(j)=pIdxMap(pixIdx)
 			cv::Mat* pSeg)
 		{
@@ -760,7 +762,7 @@ namespace ahc {
 			const int Nw   = this->width/this->windowWidth;
 
 			//1. init nodes
-			std::vector<PlaneSeg::Ptr> G(Nh*Nw,0);
+			std::vector<PlaneSeg::Ptr> G(Nh*Nw,NULL);
 			//this->blkStats.resize(Nh*Nw);
 
 #ifdef DEBUG_INIT
@@ -1132,4 +1134,4 @@ namespace ahc {
 			return step;
 		}
 	};//end of PlaneFitter
-}//end of namespace ahc
\ No newline at end of file
+}//end of namespace ahc
diff --git a/include/eig33sym.hpp b/include/eig33sym.hpp
index fc90b02..2ef644f 100644
--- a/include/eig33sym.hpp
+++ b/include/eig33sym.hpp
@@ -71,8 +71,14 @@ namespace LA {
 			Eigen::Map<Eigen::Matrix3d>(K[0], 3, 3) );
 		Eigen::Map<Eigen::Vector3d>(s,3,1)=es.eigenvalues();
 		//below we need to specify row major since V!=V'
-		Eigen::Map<Eigen::Matrix<double,3,3,Eigen::RowMajor>>(V[0],3,3)=es.eigenvectors();
+		//Eigen::Map<Eigen::Matrix<double,3,3,Eigen::RowMajor>>(V[0],3,3)=es.eigenvectors();
+		Eigen::MatrixXd mat33(3, 3);
+		for(int i = 0; i < 3; ++i)
+		{
+		  mat33.row(i) = Eigen::VectorXd::Map(&(V[i][0]), 3);
+		}
+		mat33 = es.eigenvectors();
 #endif
 		return true;
 	}
-}//end of namespace LA
\ No newline at end of file
+}//end of namespace LA
